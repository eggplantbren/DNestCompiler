\documentclass[letterpaper, 11pt]{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage[left=3cm,top=3cm,right=3cm]{geometry}

\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\parindent=0cm

\newcommand{\dnest}{{\tt DNest}}
\newcommand{\mymodel}{{\tt MyModel}}

\title{Desiderata}
%\author{Brendon J. Brewer}

\begin{document}
\maketitle


I like the implementation of the BUGS language that is used in JAGS, but there
are some things about the language in STAN that are better, so those should
be used too (e.g. parameterising normal distributions using standard deviation
instead of precision, and calling it {\tt normal} instead of {\tt dnorm}).

\section{Simple Example}
Suppose we have a problem with one parameter called $\theta$ and a data value
called $x$. Let
the prior be $\theta \sim \textnormal{Uniform}(-10, 10)$ and let the likelihood
function
be $x \sim \mathcal{N}(\theta, \sigma^2)$ where $\sigma$ is a known fixed
standard deviation (a deterministic parent node in the graphical model).

For convenience from a \dnest~point of view, it makes sense to divide
the model specification into three blocks. The prior (which also defines all
named parameters), any deterministic nodes (things that are either known
a priori, or
derivable from the parameters using a given formula), and the likelihood.

\subsection{How this should look}

This would be coded as:
\begin{verbatim}
# Note that the decimal points are my way of being
# a bit pedantic about knowing what's a double and what's an int.
prior
{
    theta ~ uniform(0., 1.)
}

deterministic
{
    sigma <- 1.
}

likelihood
{
    x ~ normal(theta, sigma)
}
\end{verbatim}

\subsection{How this should look in \dnest}
Forget about the likelihood part for starters, just focus on the prior and
deterministic parts. If you scan the lines inside the {\tt prior} and
{\tt deterministic} blocks, you get the names of all variables that need to
be declared in the \mymodel~class. For our example, the C++ code for this
declaration would be:

\begin{verbatim}
class MyModel:public DNest3::Model
{
    private:
        // Parameters
        double theta;

        // Deterministic nodes
        double sigma;
}
\end{verbatim}

There should also be a method that calculates all the deterministic nodes.
\begin{verbatim}
class MyModel:public DNest3::Model
{
    private:
        void calculate_deterministic_nodes();
}
\end{verbatim}
The implementation of this in \mymodel{\tt.cpp} should look like:
\begin{verbatim}
void MyModel::calculate_deterministic_nodes()
{
    sigma = 1.;
}
\end{verbatim}
The {\tt fromPrior()} method should look like:
\begin{verbatim}
void MyModel::fromPrior()
{
    theta = randomU(); // randomU() is my home-made alias

    calculate_deterministic_nodes();
}
\end{verbatim}
The proposal distributions need to be specified in the \mymodel~class.
These need to imply the prior distribution. For a uniform prior like in our
example, it should look like this:
\begin{verbatim}
double MyModel::perturb()
{
    // Hastings factors for if the proposal doesn't imply the prior
    double logH = 0.;

    // The coefficient out the front is the width of the prior.
    // Therefore the biggest steps are of order the prior width.
    theta += 1.*pow(10., 1.5 - 6.*randomU())*randn();

    // Make sampling the prior rejection-free!
    theta = mod(theta, 1.);

    calculate_deterministic_nodes();

    return logH;
}
\end{verbatim}

\end{document}

